#!/bin/bash
#
# sshrun - A utility to securely execute a command on a remote server
# by piping necessary files over SSH, running the command in a temporary directory,
# and automatically cleaning up afterward.
#
# Usage:
# sshrun user@host "remote_command_to_run" file1 file2 directory/
#
# The output (stdout) of the remote command is printed locally.

sshrun_main() {
    # --- Configuration ---
    # Set the remote shell command to use (defaulting to 'bash')
    local REMOTE_SHELL_COMMAND="bash"
    # Check for required arguments
    if [ "$#" -lt 3 ]; then
        echo "Usage: $0 <user@host> \"<remote_command>\" <file_to_send> [file_to_send...]" >&2
        echo "Example: $0 user@server 'chmod +x script.sh; ./script.sh arg1' script.sh config.txt" >&2
        return 1 # Use return for functions, exit for scripts
    fi

    # 1. Parse Arguments
    local REMOTE_HOST="$1"
    local REMOTE_COMMAND="$2"
    # Shift positional parameters to isolate files/directories list
    shift 2
    local FILES_TO_SEND=("$@")

    # Enable errexit for the main script
    set -e

    echo "--- Initiating Secure Remote Execution ---" >&2
    echo "Host: ${REMOTE_HOST}" >&2
    echo "Files: ${FILES_TO_SEND[*]}" >&2
    echo "Command: ${REMOTE_COMMAND}" >&2
    echo "------------------------------------------" >&2

    # --- Remote Script Definition Template ---
    # This block defines the script that will run on the remote machine.
    # It uses a placeholder 'REMOTE_COMMAND_PLACEHOLDER' that will be replaced
    # with the actual, safely escaped command before the script is sent to the remote host.
    # We use a 'trap' to ensure cleanup happens even if the command fails (or is interrupted).
    local REMOTE_SCRIPT_TEMPLATE
    read -r -d '' REMOTE_SCRIPT_TEMPLATE <<'EOF_REMOTE_SCRIPT_TEMPLATE'
        # 1. Create a secure, temporary directory and navigate into it
        # The temporary directory name is securely generated by mktemp.
        TMPDIR=$(mktemp -d -p /dev/shm);
        if [ $? -ne 0 ]; then
            echo "Error: Could not create temporary directory." >&2;
            exit 1;
        fi

        # Function to clean up the temporary directory
        cleanup() {
            # Store current errexit state and disable it temporarily to ensure cleanup commands run
            local original_errexit_state=$(set +o | grep -q 'errexit'; echo $?)
            set +e
            if [ -d "$TMPDIR" ]; then
                echo "--- Remote Cleanup: Removing $TMPDIR ---" >&2
                rm -rf "$TMPDIR"
            fi
            # Restore original errexit state
            if [ "$original_errexit_state" -eq 0 ]; then
                set -e
            fi
        }

        # Ensure cleanup runs upon exit, failure (ERR), interruption (INT), hangup (HUP), or termination (TERM) as early as possible
        trap cleanup EXIT ERR INT HUP TERM

        # Enable errexit *after* the trap is set and the temporary directory is confirmed,
        # so that subsequent command failures (like tar extraction) trigger the trap.
        set -e
        # Enable command tracing to stderr for debugging purposes
        set -x

        cd "$TMPDIR" || { echo "Error: Failed to change to temp directory." >&2; exit 1; }
        echo "Remote working directory: $TMPDIR" >&2

        # 2. Extract files piped from the local machine (tar xzf -)
        echo "--- Remote File Transfer: Extracting files ---" >&2
        # The stdin of this remote shell is the tar archive from the local machine.
        tar xzf -
        TAR_EXIT_CODE=$?
        if [ $TAR_EXIT_CODE -ne 0 ]; then
            echo "Warning: tar xzf - exited with code $TAR_EXIT_CODE. Assuming transfer interruption and forcing cleanup." >&2
            exit $TAR_EXIT_CODE # Force exit to trigger all traps (EXIT, ERR, etc.)
        fi
        
        # 3. Execute the user-provided command
        echo "--- Remote Execution: Starting Command ---" >&2
        # Source user's environment files to ensure the command runs with expected paths/vars.
        # Use '|| true' to prevent 'set -e' from exiting if files don't exist or have errors.
        echo "Remote PATH before sourcing: $PATH" >&2
        source ~/.bashrc 2>/dev/null || true
        source ~/.profile 2>/dev/null || true
        echo "Remote PATH after sourcing: $PATH" >&2
        echo "Attempting to locate 'ls': $(which ls 2>/dev/null)" >&2
        echo "Executing command: '${REMOTE_COMMAND_PLACEHOLDER}'" >&2
        # The actual command passed from the local machine, safely embedded.
        # We use 'eval' to correctly interpret the command string, especially if it contains
        # spaces or special characters that were escaped by 'printf %q'.
        eval "REMOTE_COMMAND_PLACEHOLDER"
        COMMAND_EXIT_CODE=$?
        echo "--- Remote Execution: Command finished with exit code $COMMAND_EXIT_CODE ---" >&2

        # The 'trap cleanup EXIT' handles the directory removal now.
        # The 'exit $COMMAND_EXIT_CODE' is crucial to propagate the remote command's exit status.
        exit $COMMAND_EXIT_CODE
EOF_REMOTE_SCRIPT_TEMPLATE

    # --- Local Execution ---
    # 4. Prepare the remote script and pipe files over SSH.
    #    The `tar czf -` command sends the compressed archive to stdout.
    #    This stdout is piped directly into the remote SSH session's stdin.
    #    The output (stdout) of the remote command is printed locally.

    # Escape REMOTE_COMMAND to safely embed it into the remote script.
    # The `printf %q` format specifier is robust for zsh and bash for escaping shell arguments.
    local ESCAPED_REMOTE_COMMAND
    ESCAPED_REMOTE_COMMAND=$(printf %q "${REMOTE_COMMAND}")

    # Substitute the placeholder in the template with the escaped remote command.
    # This substitution happens locally.
    local FINAL_REMOTE_SCRIPT_CONTENT
    FINAL_REMOTE_SCRIPT_CONTENT="${REMOTE_SCRIPT_TEMPLATE//REMOTE_COMMAND_PLACEHOLDER/${ESCAPED_REMOTE_COMMAND}}"

    # Prepare the remote script content, escaping single quotes for safe embedding
    # within a single-quoted string for the remote 'bash -c' command.
    # We replace each single quote with '\'' (single quote, backslash, single quote, single quote).
    # This effectively closes the current single-quoted string, inserts an escaped single quote,
    # and then starts a new single-quoted string, allowing the remote shell to parse it correctly.
    local ESCAPED_SCRIPT_FOR_BASH_C
    ESCAPED_SCRIPT_FOR_BASH_C=$(echo "${FINAL_REMOTE_SCRIPT_CONTENT}" | sed "s/'/'\\\''/g")

    # Construct the full command string for ssh.
    # The entire script is passed as a single argument to 'bash -c'.
    # This ensures proper parsing by the remote shell.
    local COMMAND_FOR_SSH="${REMOTE_SHELL_COMMAND} -c '${ESCAPED_SCRIPT_FOR_BASH_C}'"

    # Check if 'pv' is installed for progress bar functionality
    local USE_PV=false
    if command -v pv &> /dev/null; then
        USE_PV=true
    else
        echo "Warning: 'pv' command not found. File transfer progress bar will not be shown." >&2
        echo "To install 'pv', use: 'sudo apt install pv' (Debian/Ubuntu) or 'sudo yum install pv' (CentOS/RHEL) or 'brew install pv' (macOS)." >&2
    fi

    set -o pipefail
    
    local pipeline_success=false
    if "$USE_PV"; then
        # Execute the final pipeline with pv for progress: local_tar -> pv -> ssh.
        # pv writes its output to stderr. We use --force to ensure it displays a progress bar.
        if tar czf - "${FILES_TO_SEND[@]}" | pv --force | ssh -T "${REMOTE_HOST}" "${COMMAND_FOR_SSH}"; then
            pipeline_success=true
        fi
    else
        # Execute the final pipeline without pv: local_tar -> ssh.
        if tar czf - "${FILES_TO_SEND[@]}" | ssh -T "${REMOTE_HOST}" "${COMMAND_FOR_SSH}"; then
            pipeline_success=true
        fi
    fi

    # Check the result of the pipeline execution
    if ! "$pipeline_success"; then
        local PIPELINE_EXIT_CODE=$? # Capture the exit code from the failed pipeline
        echo "Error: Remote execution pipeline failed with exit code $PIPELINE_EXIT_CODE" >&2
        return $PIPELINE_EXIT_CODE
    fi
    # If successful, get the exit code from the last command in the pipeline (ssh)
    local PIPELINE_EXIT_CODE=$?
    
    echo "--- Final Status: Pipeline Exit Code $PIPELINE_EXIT_CODE ---" >&2
    return $PIPELINE_EXIT_CODE
}

# Call the main function with all script arguments
sshrun_main "$@"
exit $?
