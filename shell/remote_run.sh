#!/bin/bash
#
# remote_run.sh - A utility function to securely execute a command on a remote server
# by piping necessary files over SSH, running the command in a temporary directory,
# and automatically cleaning up afterward.
#
# Usage:
# ssh_run_temp user@host "remote_command_to_run" file1 file2 directory/
#
# The output (stdout) of the remote command is printed locally.

# --- Configuration ---
# Set the remote shell command to use (defaulting to 'bash')
REMOTE_SHELL_COMMAND="bash"

# --- Helper Function ---
# Function to perform the remote execution
ssh_run_temp() {
    # Check for required arguments
    if [ "$#" -lt 3 ]; then
        echo "Usage: ssh_run_temp <user@host> \"<remote_command>\" <file_to_send> [file_to_send...]" >&2
        echo "Example: ssh_run_temp user@server 'chmod +x script.sh; ./script.sh arg1' script.sh config.txt" >&2
        return 1
    fi

    # 1. Parse Arguments
    REMOTE_HOST="$1"
    REMOTE_COMMAND="$2"
    # Shift positional parameters to isolate files/directories list
    shift 2
    FILES_TO_SEND=("$@")

    echo "--- Initiating Secure Remote Execution ---" >&2
    echo "Host: ${REMOTE_HOST}" >&2
    echo "Files: ${FILES_TO_SEND[*]}" >&2
    echo "Command: ${REMOTE_COMMAND}" >&2
    echo "------------------------------------------" >&2

    # --- Remote Script Definition ---
    # This block defines the script that will run on the remote machine.
    # It must be safe against variable expansion by the local shell, hence the single quotes.
    # We use a 'trap' to ensure cleanup happens even if the command fails (or is interrupted).
    REMOTE_SCRIPT='
        # 1. Create a secure, temporary directory and navigate into it
        # The temporary directory name is securely generated by mktemp.
        TMPDIR=$(mktemp -d);
        if [ $? -ne 0 ]; then
            echo "Error: Could not create temporary directory." >&2;
            exit 1;
        fi

        # Function to clean up the temporary directory
        cleanup() {
            if [ -d "$TMPDIR" ]; then
                echo "--- Remote Cleanup: Removing $TMPDIR ---" >&2
                rm -rf "$TMPDIR"
            fi
        }

        # Ensure cleanup runs upon exit, failure (ERR), or interruption (INT)
        trap cleanup EXIT ERR INT

        cd "$TMPDIR" || { echo "Error: Failed to change to temp directory." >&2; exit 1; }
        echo "Remote working directory: $TMPDIR" >&2

        # 2. Extract files piped from the local machine (tar xzf -)
        echo "--- Remote File Transfer: Extracting files ---" >&2
        tar xzf -
        
        # 3. Execute the user-provided command
        echo "--- Remote Execution: Starting Command ---" >&2
        # The actual command passed from the local machine:
        /bin/bash -c "source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; '"$REMOTE_COMMAND"'"
        COMMAND_EXIT_CODE=$?
        echo "--- Remote Execution: Command finished with exit code $COMMAND_EXIT_CODE ---" >&2

        # The 'trap cleanup EXIT' handles the directory removal now.
        exit $COMMAND_EXIT_CODE
    '

    # --- Local Execution ---
    # 4. Archive the necessary files and pipe them over SSH
    #    The `tar czf -` command sends the compressed archive to stdout.
    #    This stdout is piped directly into the remote SSH session's stdin.
    #    The output of the remote command (stdout only) is captured by the main script.
    
    # We use 'eval' here to ensure the command is correctly constructed and run
    # (especially important if using custom SSH commands or settings).
    # The 'tar' command must be run successfully before piping.

    # Redirect stderr of the SSH connection to the terminal (>&2)
    # The stdout of the remote script goes to the local stdout.
    
    # Check if the tar command succeeded before piping
    if ! tar czf - "${FILES_TO_SEND[@]}" > /dev/null 2>&1; then
        echo "Error: Failed to create local tar archive. Check file paths: ${FILES_TO_SEND[*]}" >&2
        return 1
    fi
    
    # Execute the final pipeline
    eval "tar czf - \"\${FILES_TO_SEND[@]}\" | ssh -T \"${REMOTE_HOST}\" \"${REMOTE_SHELL_COMMAND} -s\" <<< \"\$REMOTE_SCRIPT\""
    
    # Capture the exit code of the entire pipeline (which is the exit code of the remote command)
    PIPELINE_EXIT_CODE=$?
    
    echo "--- Final Status: Pipeline Exit Code $PIPELINE_EXIT_CODE ---" >&2
    return $PIPELINE_EXIT_CODE
}

# Example of how to use this function (commented out):
# ----------------------------------------------------
# 1. Create dummy files for demonstration
# echo "Hello from local file 1" > file1.txt
# echo "function test() { echo 'Running Test function'; }" > myscript.sh
# chmod +x myscript.sh
# mkdir -p mydata
# echo "Data point 1" > mydata/data.csv

# 2. Execute the function (replace user@host with your actual connection details)
# Note: The command in quotes needs to be executed on the remote machine.
# ssh_run_temp user@host "chmod +x myscript.sh; ./myscript.sh; cat file1.txt; cat mydata/data.csv" file1.txt myscript.sh mydata

# 3. Clean up local dummy files
# rm -f file1.txt myscript.sh
# rm -rf mydata

# To use this, you must source the script:
# source remote_run.sh
# Then execute:
# ssh_run_temp user@yourserver "echo 'Hello remote world!'" file1.txt
