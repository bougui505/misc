#!/bin/bash
#
# remote_run.sh - A utility function to securely execute a command on a remote server
# by piping necessary files over SSH, running the command in a temporary directory,
# and automatically cleaning up afterward.
#
# Usage:
# sshrun user@host "remote_command_to_run" file1 file2 directory/
#
# The output (stdout) of the remote command is printed locally.

# --- Configuration ---
# Set the remote shell command to use (defaulting to 'bash')
REMOTE_SHELL_COMMAND="bash"

# --- Helper Function ---
# Function to perform the remote execution
sshrun() {
    # Check for required arguments
    if [ "$#" -lt 3 ]; then
        echo "Usage: sshrun <user@host> \"<remote_command>\" <file_to_send> [file_to_send...]" >&2
        echo "Example: sshrun user@server 'chmod +x script.sh; ./script.sh arg1' script.sh config.txt" >&2
        return 1
    fi

    # 1. Parse Arguments
    REMOTE_HOST="$1"
    REMOTE_COMMAND="$2"
    # Shift positional parameters to isolate files/directories list
    shift 2
    FILES_TO_SEND=("$@")

    echo "--- Initiating Secure Remote Execution ---" >&2
    echo "Host: ${REMOTE_HOST}" >&2
    echo "Files: ${FILES_TO_SEND[*]}" >&2
    echo "Command: ${REMOTE_COMMAND}" >&2
    echo "------------------------------------------" >&2

    # --- Remote Script Definition Template ---
    # This block defines the script that will run on the remote machine.
    # It uses a placeholder 'REMOTE_COMMAND_PLACEHOLDER' that will be replaced
    # with the actual, safely escaped command before the script is sent to the remote host.
    # We use a 'trap' to ensure cleanup happens even if the command fails (or is interrupted).
    local REMOTE_SCRIPT_TEMPLATE
    read -r -d '' REMOTE_SCRIPT_TEMPLATE <<'EOF_REMOTE_SCRIPT_TEMPLATE'
        # 1. Create a secure, temporary directory and navigate into it
        # The temporary directory name is securely generated by mktemp.
        TMPDIR=$(mktemp -d -p /dev/shm);
        if [ $? -ne 0 ]; then
            echo "Error: Could not create temporary directory." >&2;
            exit 1;
        fi

        # Function to clean up the temporary directory
        cleanup() {
            # Store current errexit state and disable it temporarily to ensure cleanup commands run
            local original_errexit_state=$(set +o | grep -q 'errexit'; echo $?)
            set +e
            if [ -d "$TMPDIR" ]; then
                echo "--- Remote Cleanup: Removing $TMPDIR ---" >&2
                rm -rf "$TMPDIR"
            fi
            # Restore original errexit state
            if [ "$original_errexit_state" -eq 0 ]; then
                set -e
            fi
        }

        # Ensure cleanup runs upon exit, failure (ERR), interruption (INT), hangup (HUP), or termination (TERM) as early as possible
        trap cleanup EXIT ERR INT HUP TERM

        # Enable errexit *after* the trap is set and the temporary directory is confirmed,
        # so that subsequent command failures (like tar extraction) trigger the trap.
        set -e

        cd "$TMPDIR" || { echo "Error: Failed to change to temp directory." >&2; exit 1; }
        echo "Remote working directory: $TMPDIR" >&2

        # 2. Extract files piped from the local machine (tar xzf -)
        echo "--- Remote File Transfer: Extracting files ---" >&2
        # The stdin of this remote shell is the tar archive from the local machine.
        tar xzf -
        TAR_EXIT_CODE=$?
        if [ $TAR_EXIT_CODE -ne 0 ]; then
            echo "Warning: tar xzf - exited with code $TAR_EXIT_CODE. Assuming transfer interruption and forcing cleanup." >&2
            exit $TAR_EXIT_CODE # Force exit to trigger all traps (EXIT, ERR, etc.)
        fi
        
        # 3. Execute the user-provided command
        echo "--- Remote Execution: Starting Command ---" >&2
        # The actual command passed from the local machine, safely embedded.
        # We use the bash -c 'CMD' _ ARG1 ARG2... idiom for safe execution.
        /bin/bash -c "source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; \"\$0\"" "REMOTE_COMMAND_PLACEHOLDER"
        COMMAND_EXIT_CODE=$?
        echo "--- Remote Execution: Command finished with exit code $COMMAND_EXIT_CODE ---" >&2

        # The 'trap cleanup EXIT' handles the directory removal now.
        # The 'exit $COMMAND_EXIT_CODE' is crucial to propagate the remote command's exit status.
        exit $COMMAND_EXIT_CODE
EOF_REMOTE_SCRIPT_TEMPLATE

    # --- Local Execution ---
    # 4. Prepare the remote script and pipe files over SSH.
    #    The `tar czf -` command sends the compressed archive to stdout.
    #    This stdout is piped directly into the remote SSH session's stdin.
    #    The output (stdout) of the remote command is printed locally.

    # Escape REMOTE_COMMAND to safely embed it into the remote script.
    # The `printf %q` format specifier is robust for zsh and bash for escaping shell arguments.
    local ESCAPED_REMOTE_COMMAND
    ESCAPED_REMOTE_COMMAND=$(printf %q "${REMOTE_COMMAND}")

    # Substitute the placeholder in the template with the escaped remote command.
    # This substitution happens locally.
    local FINAL_REMOTE_SCRIPT_CONTENT
    FINAL_REMOTE_SCRIPT_CONTENT="${REMOTE_SCRIPT_TEMPLATE//REMOTE_COMMAND_PLACEHOLDER/${ESCAPED_REMOTE_COMMAND}}"

    # The entire FINAL_REMOTE_SCRIPT_CONTENT needs to be passed as a single argument to ssh,
    # and then executed by the remote shell. To do this safely, we need to quote it robustly
    # for the local shell's argument parsing.
    local QUOTED_FINAL_REMOTE_SCRIPT
    QUOTED_FINAL_REMOTE_SCRIPT=$(printf %q "${FINAL_REMOTE_SCRIPT_CONTENT}")

    # Check if 'pv' is installed for progress bar functionality
    local USE_PV=false
    if command -v pv &> /dev/null; then
        USE_PV=true
    else
        echo "Warning: 'pv' command not found. File transfer progress bar will not be shown." >&2
        echo "To install 'pv', use: 'sudo apt install pv' (Debian/Ubuntu) or 'sudo yum install pv' (CentOS/RHEL) or 'brew install pv' (macOS)." >&2
    fi

    set -o pipefail
    
    local pipeline_success=false
    if "$USE_PV"; then
        # Execute the final pipeline with pv for progress: local_tar -> pv -> ssh.
        # pv writes its output to stderr. We use --force to ensure it displays a progress bar.
        if tar czf - "${FILES_TO_SEND[@]}" | pv --force | ssh -T "${REMOTE_HOST}" "${REMOTE_SHELL_COMMAND} -c ${QUOTED_FINAL_REMOTE_SCRIPT}"; then
            pipeline_success=true
        fi
    else
        # Execute the final pipeline without pv: local_tar -> ssh.
        if tar czf - "${FILES_TO_SEND[@]}" | ssh -T "${REMOTE_HOST}" "${REMOTE_SHELL_COMMAND} -c ${QUOTED_FINAL_REMOTE_SCRIPT}"; then
            pipeline_success=true
        fi
    fi

    # Check the result of the pipeline execution
    if ! "$pipeline_success"; then
        PIPELINE_EXIT_CODE=$? # Capture the exit code from the failed pipeline
        echo "Error: Remote execution pipeline failed with exit code $PIPELINE_EXIT_CODE" >&2
        return $PIPELINE_EXIT_CODE
    fi
    # If successful, get the exit code from the last command in the pipeline (ssh)
    PIPELINE_EXIT_CODE=$?
    
    echo "--- Final Status: Pipeline Exit Code $PIPELINE_EXIT_CODE ---" >&2
    return $PIPELINE_EXIT_CODE
}

# Example of how to use this function (commented out):
# ----------------------------------------------------
# 1. Create dummy files for demonstration
# echo "Hello from local file 1" > file1.txt
# echo "function test() { echo 'Running Test function'; }" > myscript.sh
# chmod +x myscript.sh
# mkdir -p mydata
# echo "Data point 1" > mydata/data.csv

# 2. Execute the function (replace user@host with your actual connection details)
# Note: The command in quotes needs to be executed on the remote machine.
# sshrun user@host "chmod +x myscript.sh; ./myscript.sh; cat file1.txt; cat mydata/data.csv" file1.txt myscript.sh mydata

# 3. Clean up local dummy files
# rm -f file1.txt myscript.sh
# rm -rf mydata

# To use this, you must source the script:
# source remote_run.sh
# Then execute:
# sshrun user@yourserver "echo 'Hello remote world!'" file1.txt
